## 1. 什么是Vulkan
Vulkan是新一代的图形和计算API，它提供了对现代图形硬件的跨平台高效访问。

### 1.1 核心概念
就本质而言，Vulkan是一套API规范。相比于OpenGL，Vulkan并不是其直接替代，而是一种允许更明确地调用GPU的显式API。

### 1.2 OpenGL ES vs. Vulkan
- **状态管理**：OpenGL ES使用一个全局状态来描述，因而每次draw call都需要重新创建必要的渲染状态和资源绑定表。由于状态绑定只在绘制阶段被确定，所以一些优化算法无法适用。Vulkan则使用状态对象（描述符）来描述渲染状态，这就允许上层应用提前将一些状态绑定打包起来。从而能采用一些基于Shader的优化方案，降低运行期开销。状态管理上的优化显著降低了CPU端的调度开销，代价是需要上层应用提前确定好状态。
- **API执行模型**：OpenGL ES采用同步渲染执行模型，也就是各API调度必须按顺序执行。实际上，现代GPU不会这么处理，各种GPU资源调度仍然是异步进行的。但为了确保API层面上的同步执行，硬件驱动必须追踪各资源的读写来确保各渲染操作的正确执行。Vulkan则使用异步渲染执行模型，与现代GPU的底层模式相合。上层应用将渲染指令填充进指令队列中，使用显式的调度依赖来控制执行顺序，并且使用显式的异步原语来对齐CPU和GPU的处理。
- **API线程模型**：OpenGL ES使用单线程渲染模型，这大大制约了多核处理器在渲染任务中的发挥。Vulkan则使用多线程渲染模型。值得一提的是，ARM的处理器通常使用了”异构多核技术“（也就是所谓的”大小核“），该技术将高性能的”大核“与节能的”小核“结合使用，该技术可以大幅减少处理器的功耗，并能及时释放渲染所需的资源。
- **API错误检查**：OpenGL ES是一个严格的API规范，有着广泛的错误检查。有些错误仅限于开发过程中会发生，运行时并不能有效处理，但OpenGL ES的错误检查仍然会进行，这增加了驱动和发布版本应用的负担。Vulkan则使用一个精简的核心规范，不要求驱动实现运行时错误检查。对API的无效使用可能会引发渲染中断或应用崩溃。作为全周期错误检查的替代，Vulkan提供了一个框架，允许在应用程序和本机Vulkan驱动程序之间插入层驱动。这些层可用于实现错误检查、debug，以及任何发布版本应用中可以移除的工作。
- **渲染通道的抽象**：OpenGL ES中并没有渲染通道（render pass）对象这样的概念，但这样的概念对于像Mali这样的tile-based渲染器尤为重要。驱动需要在运行时推断哪些渲染指令构成了一个渲染通道，这类任务通常会占用一些时间，而启发式方法也并不准确。Vulkan则是围绕渲染通道概念构建的，并且还额外引入了子通道（subpass）的概念用于自动转译一个渲染通道中分片内（in-tile）的着色操作。这些显式编码可以完全去除运行时的启发式方法，也可以通过预构建来进一步降低运行时开销。
- **内存分配**：OpenGL ES使用客户端-服务器（C/S）内存模型。这种模型显式地划分了客户端（CPU端）资源和服务器（GPU）资源，并提供相应的函数实现数据在两者之间的转移。但这种模型有两种明显的缺点：1. 应用层无法直接分配和管理后台服务端的资源；2. 在客户端和服务器之间同步资源需要额外的开销，特别是API同步执行与实际的异步处理上存在冲突时。Vulkan是为现代硬件设计的，假定了CPU和GPU上某种程度的内存一致性。Vulkan API允许应用层直接控制一些内存资源（分配、更新等）。内存一致性使得缓冲的地址映射持久有效，避免了OpenGL ES中地址映射与取消映射的循环。
- **内存使用**：OpenGL ES使用一种重度的类型对象模型，将逻辑资源与物理内存紧密耦合。这使得用起来简便，但意味着存在大量的中间存储。Vulkan将不同的资源概念和其背后的物理内存做了区分，例如图片。这使得内存调度可以重复利用同一块物理内存来存储渲染管线中不同阶段的不同资源。这种区分设计可以通过循环使用同一块内存来降低上层应用在每帧中的内存占用。区分设计和内存可变性也会对驱动端优化施加一些限制，特别是像帧缓冲压缩这种改变内存布局的优化。

### 1.3 Vulkan的目标
虽然Vulkan提供了大量的优化手段，但同时也意味着将许多开发和维护的责任转交到了应用层开发者的手中。在使用Vulkan开发之前，需要思考清楚Vulkan带来的收益以及需要为此付出的代价。
Vulkan并不能带来直接的性能提升，暴露给Vulkan和OpenGL ES的硬件是相同的，它们所使用的渲染方法也大致相同。但Vulkan可以降低CPU的负载，间接支持了更高的GPU频率。
Vulkan最大的优势在于降低渲染逻辑中的CPU负载，这是通过简化API接口以及支持多线程实现的。Vulkan的第二个优势在于降低了应用的内存占用，这是通过帧内资源回收利用实现的，对RAM受限的设备有很大价值。
Vulkan最大的缺点在于将大量的职责转变到了应用层，包括内存分配、依赖管理、CPU-GPU同步。这是一把双刃剑，在细化控制粒度的同时，增加了风险。Vulkan的另一个巨大的弊端在于其极小的抽象层很容易暴露硬件之间的差异。例如OpenGL ES的依赖完全由驱动把控，所以能假定执行正确的操作；但Vulkan由应用层控制，有些在传统管线中运行良好的渲染通道可能在tile-base渲染中显得过于保守。